Homework. Locks
=================

- [Homework. Locks](#homework-locks)
  - [Описание](#описание)
    - [Цели](#цели)
  - [Задание и выполнение](#задание-и-выполнение)
    - [Задание 1](#задание-1)
    - [Задание 2](#задание-2)
    - [Задание 3](#задание-3)
    - [Задание 4 + Задание со \*](#задание-4--задание-со-)

Описание
--------

Механизм блокировок.

### Цели

- понимать как работает механизм блокировок объектов и строк

Задание и выполнение
--------------------

### Задание 1

> Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд.

```sql
-- Смотрим текущее значение параметра log_lock_waits и deadlock_timeout
postgres=# SHOW log_lock_waits;
 log_lock_waits 
----------------
 off
(1 row)

postgres=# SHOW deadlock_timeout;
 deadlock_timeout 
------------------
 1s
(1 row)

-- Включаем логирование и устанавливаем значение логирования в 200мс
postgres=# ALTER SYSTEM SET log_lock_waits TO on;
ALTER SYSTEM

postgres=# ALTER SYSTEM SET deadlock_timeout TO 200;
ALTER SYSTEM

-- Перечитываем конфигурацию
postgres=# SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

-- Проверяем значение параметров
postgres=# SHOW log_lock_waits;
 log_lock_waits 
----------------
 on
(1 row)

postgres=# SHOW deadlock_timeout;
 deadlock_timeout 
------------------
 200ms
(1 row)
```

> Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

```sql
/*
  Этап подготовки
*/

-- Создадим таблицу locks
postgres=# CREATE TABLE locks (a integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, b integer);
CREATE TABLE

-- Добавим несколько значений в таблицу
postgres=# INSERT INTO locks (b) VALUES (10), (20), (30);
INSERT 0 3

-- Проверим наличие строк
postgres=# SELECT * FROM locks;
 a | b  
---+----
 1 | 10
 2 | 20
 3 | 30
(3 rows)

/*
  Основной этап
*/

-- 1 сессия. Запускаем транзакцию и обновляем одну строку
postgres=# BEGIN;
BEGIN

postgres=*# UPDATE locks SET b = 11 WHERE a = 1;
UPDATE 1

-- 2 сессия. Делаем тоже самое
postgres=# BEGIN;
BEGIN

postgres=*# UPDATE locks SET b = 12 WHERE a = 1;
-- ... Тут повисли
```

Смотрим логи и видим сообщения о блокировке, а так же какие pid'ы в этом участвуют:

```bash
root@fhmodlacmieaul194lf0:/home/student# tail -f /var/log/postgresql/postgresql-15-main.log
...
2024-01-24 19:40:22.783 UTC [1244] postgres@postgres DETAIL:  Process holding the lock: 1321. Wait queue: 1244.
2024-01-24 19:40:22.783 UTC [1244] postgres@postgres CONTEXT:  while updating tuple (0,1) in relation "locks"
2024-01-24 19:40:22.783 UTC [1244] postgres@postgres STATEMENT:  UPDATE locks SET b = 12 WHERE a = 1;
```

Возвращемся в сессии psql:

```sql
-- 1 сессия. Коммитим изменения
postgres=*# COMMIT;
COMMIT

-- 2 сессия. Коммитим изменения после снятия блокировки
-- postgres=*# UPDATE locks SET b = 12 WHERE a = 1;
UPDATE 1

postgres=*# COMMIT;
COMMIT

-- Смотрим содержимое таблицы
postgres=# SELECT * FROM locks;
 a | b  
---+----
 2 | 20
 3 | 30
 1 | 12
(3 rows)
```

### Задание 2

> Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах.

Повторим историю, но уже с 3 сессиями psql:

```sql
-- 1 сессия. Находим pid backend'а, запускаем транзакцию и обновляем одну строку
postgres=# BEGIN;
BEGIN

postgres=*# SELECT pg_backend_pid();
 pg_backend_pid 
----------------
           1321
(1 row)

postgres=*# UPDATE locks SET b = 21 WHERE a = 2;
UPDATE 1

-- 2 сессия. Повторяем операцию

postgres=# BEGIN;
BEGIN

postgres=*# SELECT pg_backend_pid();
 pg_backend_pid 
----------------
           1244
(1 row)

postgres=*# UPDATE locks SET b = 22 WHERE a = 2;
-- ... Тут повисли

-- 3 сессия. Повторяем операцию
postgres=# BEGIN;
BEGIN

postgres=*# SELECT pg_backend_pid();
 pg_backend_pid 
----------------
           1469
(1 row)

postgres=*# UPDATE locks SET b = 23 WHERE a = 2;
-- ... Тут повисли
```

> Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.

```sql
-- Смотрим список блокировок на таблице locks
postgres=# SELECT relation::REGCLASS, locktype, mode, granted, pid, pg_blocking_pids(pid) AS wait_for FROM pg_locks WHERE relation = 'locks'::regclass AND locktype = 'relation';
 relation | locktype |       mode       | granted | pid  | wait_for 
----------+----------+------------------+---------+------+----------
 locks    | relation | RowExclusiveLock | t       | 1469 | {1244}
 locks    | relation | RowExclusiveLock | t       | 1321 | {}
 locks    | relation | RowExclusiveLock | t       | 1244 | {1321}
(3 rows)
```

Здесь мы видим 3 блокировки `RowExclusiveLock` (операция `UPDATE`) на уровне таблицы locks. Блокировка `RowExclusiveLock` на уровне таблицы разрешает одновременное изменение данных (`granted = true`).

Возвращаемся в сессии psql:

```sql
-- 1 сессия. Коммитим изменения.
postgres=*# COMMIT;
COMMIT

-- 2 сессия. Видим что блокировка снята
-- postgres=*# UPDATE locks SET b = 22 WHERE a = 2;
UPDATE 1

-- Снова посмотрим список блокировок
postgres=# SELECT relation::REGCLASS, locktype, mode, granted, pid, pg_blocking_pids(pid) AS wait_for FROM pg_locks WHERE relation = 'locks'::regclass AND locktype = 'relation';
 relation | locktype |       mode       | granted | pid  | wait_for 
----------+----------+------------------+---------+------+----------
 locks    | relation | RowExclusiveLock | t       | 1469 | {1244}
 locks    | relation | RowExclusiveLock | t       | 1244 | {}
(2 rows)
```

Видим, что осталось 2 блокировки. Вторая сессия с pid'ом `1244` больше не ждет окончания транзакции сессии с pid'ом `1321`.

Закомитим оставшиеся транзакции:

```sql
-- 2 сессия.
postgres=*# COMMIT;
COMMIT

-- 3 сессия. Блокировка снята
-- postgres=*# UPDATE locks SET b = 23 WHERE a = 2;
UPDATE 1

postgres=*# COMMIT;
COMMIT

-- Смотрим строки таблицы locks
postgres=# SELECT * FROM locks;
 a | b  
---+----
 3 | 30
 1 | 12
 2 | 23
(3 rows)
```

### Задание 3

> Воспроизведите взаимоблокировку трех транзакций.

```sql
/*
  Этап подготовки
*/

-- Установим значение deadlock_timeout в 180000мс (3 минуты), чтобы успеть выполнить все команды и словить deadlock.
postgres=# ALTER SYSTEM SET deadlock_timeout TO 180000;
ALTER SYSTEM

-- Перечитываем конфигурацию
postgres=# SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

-- Проверяем значение параметра deadlock_timeout
postgres=# SHOW deadlock_timeout;
 deadlock_timeout 
------------------
 3min
(1 row)

/*
  Основной этап
*/

-- 1 сессия. Начинаем транзакцию и меняем значение поля b на 111 строки с полем a = 1
postgres=# BEGIN;
BEGIN

postgres=*# UPDATE locks SET b = 111 WHERE a = 1;
UPDATE 1

-- 2 сессия. Начинаем транзакцию и меняем значение поля b на 211 строки с полем a = 2
postgres=# BEGIN;
BEGIN

postgres=*# UPDATE locks SET b = 211 WHERE a = 2;
UPDATE 1

-- 3 сессия. Начинаем транзакцию и меняем значение поля b на 311 строки с полем a = 3
postgres=# BEGIN;
BEGIN

postgres=*# UPDATE locks SET b = 311 WHERE a = 3;
UPDATE 1

-- 1 сессия. Пробуем изменить значение поля b на 222 строки с полем a = 2. Тем самым создаем deadlock 1 сессия -> 2 сессии
postgres=*# UPDATE locks SET b = 222 WHERE a = 2;
-- .. Зависли

-- 2 сессия. Пробуем изменить значение поля b на 322 строки с полем a = 3. Тем самым создаем deadlock 2 сессия -> 3 сессии
postgres=*# UPDATE locks SET b = 322 WHERE a = 3;
-- .. Зависли

-- 3 сессия. Пробуем изменить значение поля b на 122 строки с полем a = 1. Тем самым создаем deadlock 3 сессия -> 1 сессии
postgres=*# UPDATE locks SET b = 122 WHERE a = 1;
-- .. Зависли

-- 1 сессия. Получили сообщение об ошибке и откатываем транзакцию.
ERROR:  deadlock detected
DETAIL:  Process 1321 waits for ShareLock on transaction 864739; blocked by process 1244.
Process 1244 waits for ShareLock on transaction 864740; blocked by process 1469.
Process 1469 waits for ShareLock on transaction 864738; blocked by process 1321.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,11) in relation "locks"

postgres=!# ROLLBACK;
ROLLBACK

-- 2 сессия. До сих пор в блокировке, но теперь это RowExclusiveLock
postgres=# SELECT relation::REGCLASS, locktype, mode, granted, pid, pg_blocking_pids(pid) AS wait_for FROM pg_locks WHERE relation = 'locks'::regclass AND locktype = 'relation';
 relation | locktype |       mode       | granted | pid  | wait_for 
----------+----------+------------------+---------+------+----------
 locks    | relation | RowExclusiveLock | t       | 1469 | {}
 locks    | relation | RowExclusiveLock | t       | 1244 | {1469}
(2 rows)

-- 3 сессия. Deadlock снят. Коммитим изменения.
-- postgres=*# UPDATE locks SET b = 122 WHERE a = 1;
UPDATE 1

postgres=*# COMMIT;
COMMIT

-- 2 сессия. Блокировка снята и мы можем коммитить изменения
-- postgres=*# UPDATE locks SET b = 322 WHERE a = 3;
UPDATE 1

postgres=*# COMMIT;
COMMIT

-- Смотрим строки таблицы
postgres=# SELECT * FROM locks;
 a |  b  
---+-----
 2 | 211
 1 | 122
 3 | 322
(3 rows)
```

В конечном итоге 2 из 3 транзакции завершились успешно и эти строки были изменены.

> Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

Да, в логах мы видим сообщения о deadlock'е:

```bash
2024-01-24 20:36:22.542 UTC [1321] postgres@postgres LOG:  process 1321 detected deadlock while waiting for ShareLock on transaction 864739 after 180000.127 ms
2024-01-24 20:36:22.542 UTC [1321] postgres@postgres DETAIL:  Process holding the lock: 1244. Wait queue: .
2024-01-24 20:36:22.542 UTC [1321] postgres@postgres CONTEXT:  while updating tuple (0,11) in relation "locks"
2024-01-24 20:36:22.542 UTC [1321] postgres@postgres STATEMENT:  UPDATE locks SET b = 222 WHERE a = 2;
2024-01-24 20:36:22.542 UTC [1321] postgres@postgres ERROR:  deadlock detected
```

### Задание 4 + Задание со *

> Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?

Не знаю, давайте проверим :)

> Попробуйте воспроизвести такую ситуацию.

```sql
-- 1 сессия. Запускаем транзакцию и меняем все строки
postgres=# BEGIN;
BEGIN

postgres=*# UPDATE locks SET b = 999;
UPDATE 3

-- 2 сессия. Запускаем транзакцию и меняем все строки
postgres=# BEGIN;
BEGIN

postgres=*# UPDATE locks SET b = 888;
-- ... Зависло

-- 1 сессия. Коммитим изменения
postgres=*# COMMIT;
COMMIT

-- 2 сессия. Блокировка снята. Коммитим изменения
-- postgres=*# UPDATE locks SET b = 888;
UPDATE 3

postgres=*# COMMIT;
COMMIT

-- Смотрим строки таблицы locks
postgres=# SELECT * FROM locks;
 a |  b  
---+-----
 2 | 888
 1 | 888
 3 | 888
(3 rows)
```

Значит да, могут.
